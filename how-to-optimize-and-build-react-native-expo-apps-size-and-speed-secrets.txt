1:"$Sreact.fragment"
3:I[7555,[],""]
4:I[1295,[],""]
6:I[9665,[],"OutletBoundary"]
9:I[9665,[],"ViewportBoundary"]
b:I[9665,[],"MetadataBoundary"]
d:I[6614,[],""]
:HL["/_next/static/css/99b878eb2c63bf62.css","style"]
0:{"P":null,"b":"vhHRu0rGS_s8F3iSG0-hX","p":"","c":["","how-to-optimize-and-build-react-native-expo-apps-size-and-speed-secrets"],"i":false,"f":[[["",{"children":["(blog)",{"children":[["blogSlug","how-to-optimize-and-build-react-native-expo-apps-size-and-speed-secrets","d"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/99b878eb2c63bf62.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],"$L2"]}],{"children":["(blog)",["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":[["blogSlug","how-to-optimize-and-build-react-native-expo-apps-size-and-speed-secrets","d"],["$","$1","c",{"children":[null,["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L5","$undefined",null,["$","$L6",null,{"children":["$L7","$L8",null]}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","L4iz0BYFkar2ugZ92PuPO",{"children":[["$","$L9",null,{"children":"$La"}],null]}],["$","$Lb",null,{"children":"$Lc"}]]}],false]],"m":"$undefined","G":["$d","$undefined"],"s":false,"S":true}
a:[["$","meta","0",{"charSet":"utf-8"}],["$","meta","1",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
7:null
8:null
c:[["$","title","0",{"children":"My Static Blog"}],["$","meta","1",{"name":"description","content":"Generated by create next app"}],["$","link","2",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
e:I[1774,["874","static/chunks/874-5b4b556a84f07a74.js","177","static/chunks/app/layout-8a976070cca146e1.js"],"default"]
2:["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__className_d65c78 antialiased","children":[["$","$Le",null,{"logo":"Baby Sleep Guides","categories":[{"id":"613b6b96-972f-45a6-b500-7797f97959b5","name":"Build Optiization","slug":"build-optiization","projectId":"66964f20-8771-420a-90a6-0742cced1c7c"},{"id":"552088e0-7fd8-481c-a761-a76a6ab1fbf4","name":"UI Tips","slug":"ui-tips","projectId":"66964f20-8771-420a-90a6-0742cced1c7c"}]}],["$","$L3",null,{"parallelRouterKey":"children","error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L4",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":"$0:f:0:1:2:children:1:props:children:1:props:notFound:0:1:props:style","children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":"$0:f:0:1:2:children:1:props:children:1:props:notFound:0:1:props:children:props:children:1:props:style","children":404}],["$","div",null,{"style":"$0:f:0:1:2:children:1:props:children:1:props:notFound:0:1:props:children:props:children:2:props:style","children":["$","h2",null,{"style":"$0:f:0:1:2:children:1:props:children:1:props:notFound:0:1:props:children:props:children:2:props:children:props:style","children":"This page could not be found."}]}]]}]}]],[]],"forbidden":"$undefined","unauthorized":"$undefined"}]]}]}]
f:I[6083,["874","static/chunks/874-5b4b556a84f07a74.js","63","static/chunks/63-3f476db0970d63fd.js","440","static/chunks/app/(blog)/%5BblogSlug%5D/page-49c77fcd91157749.js"],"default"]
10:I[6874,["874","static/chunks/874-5b4b556a84f07a74.js","63","static/chunks/63-3f476db0970d63fd.js","440","static/chunks/app/(blog)/%5BblogSlug%5D/page-49c77fcd91157749.js"],""]
11:I[3063,["874","static/chunks/874-5b4b556a84f07a74.js","63","static/chunks/63-3f476db0970d63fd.js","440","static/chunks/app/(blog)/%5BblogSlug%5D/page-49c77fcd91157749.js"],"Image"]
12:I[5068,["874","static/chunks/874-5b4b556a84f07a74.js","63","static/chunks/63-3f476db0970d63fd.js","440","static/chunks/app/(blog)/%5BblogSlug%5D/page-49c77fcd91157749.js"],"default"]
15:I[6495,["874","static/chunks/874-5b4b556a84f07a74.js","63","static/chunks/63-3f476db0970d63fd.js","440","static/chunks/app/(blog)/%5BblogSlug%5D/page-49c77fcd91157749.js"],"default"]
13:T1fa0,<article>
  <h1>How to Optimize and Build React Native Expo Apps: Size and Speed Secrets</h1>

  <p>React Native, combined with Expo, offers a rapid and convenient way to build cross-platform mobile applications. However, a common pitfall is the resulting application's size and performance, especially after building for production. This post provides actionable techniques for optimizing React Native Expo apps during the build process, focusing on reducing size and improving speed. We'll explore code optimization, asset management, bundling strategies, and considerations for native modules.</p>

  <h2 id="understanding-the-build-process">Understanding the Build Process</h2>
  <p>The <code>expo build</code> command is your gateway to creating production-ready binaries (APK for Android and IPA for iOS) from your React Native project. Under the hood, Expo leverages EAS Build (Expo Application Services) to handle bundling and native code compilation. A crucial element in this process is the <code>app.json</code> or <code>app.config.js</code> file, where you define your app's configuration. Proper configuration here is <em>essential</em> for effective optimization.</p>

  <h2 id="code-optimization-techniques">Code Optimization Techniques</h2>
  <p>Optimizing your code is paramount for a lean and performant app.</p>

  <h3>Dead Code Elimination (Tree Shaking)</h3>
  <p>Tree shaking is the process of eliminating unused code from your application bundle. Modern bundlers like Webpack can automatically perform tree shaking. To maximize its effectiveness, avoid global imports. Instead, import only the specific components or functions you need.</p>
  <p>To enable tree shaking, ensure your modules are using ES modules syntax (<code>import</code> and <code>export</code>).</p>

  <h3>Code Splitting (Dynamic Imports)</h3>
  <p>Code splitting involves dividing your application into smaller chunks, loading only the necessary code when needed. Dynamic imports, using <code>React.lazy</code> or the <code>import()</code> syntax, allow you to defer the loading of non-critical modules, reducing initial load time.</p>
  <pre><code class="language-javascript">const MyComponent = React.lazy(() =&gt; import('./MyComponent'));

function MyOtherComponent() {
  return (
    <react.suspense fallback="{<div">Loading...}&gt;
      <mycomponent>
    </mycomponent></react.suspense>
  );
}
</code></pre>

  <h3>Efficient Data Structures and Algorithms</h3>
  <p>Choosing the right data structures (e.g., <code>Map</code> vs. <code>Object</code>) and algorithms based on your specific use cases can significantly impact performance. Profile your application using tools like React Native Performance Monitor or Flipper to identify bottlenecks and optimize accordingly. For example, using <code>Map</code> might be more efficient for frequent lookups than using a plain JavaScript object as a dictionary.</p>

  <h2 id="asset-optimization">Asset Optimization</h2>
  <p>Reducing the size of your assets (images, audio, video) is crucial for a smaller app and faster download times.</p>

  <h3>Image Optimization</h3>
  <p>Compress images using lossy or lossless compression techniques. Lossy compression reduces file size more aggressively but can introduce some visual artifacts. Tools like <a href="https://imageoptim.com/" target="_blank" rel="noopener noreferrer">ImageOptim</a> or <a href="https://tinypng.com/" target="_blank" rel="noopener noreferrer">TinyPNG</a> can help. Consider using WebP images as well, as they offer superior compression compared to JPG and PNG.</p>

  <h3>Asset Resizing and Scaling</h3>
  <p>Provide multiple image resolutions for different screen densities. Expo's asset management system handles this automatically when you use the <code>require()</code> function with image assets.  Ensure you are using appropriate image sizes to avoid unnecessary bandwidth usage.</p>

  <h3>Vector Graphics (SVGs)</h3>
  <p>Use SVG images for icons and simple graphics whenever possible. SVGs are scalable and have a small file size. You can import and use SVGs in your React Native components using libraries like <code>react-native-svg</code>.</p>
  <pre><code class="language-javascript">import Svg, { Rect } from 'react-native-svg';

function MyIcon() {
  return (
    <svg width="24" height="24">
      <rect width="24" height="24" fill="#000"></rect>
    </svg>
  );
}
</code></pre>

  <h3>Audio and Video Optimization</h3>
  <p>If your app includes audio or video assets, optimize them through compression and by using appropriate codecs.</p>

  <h2 id="bundling-strategies">Bundling Strategies</h2>
  <p>The way your code is bundled can significantly affect app size and startup time.</p>

  <h3>Hermes Engine</h3>
  <p>The Hermes JavaScript engine is designed for React Native. It offers improved startup time and reduced app size.  Enable Hermes in your <code>app.json</code> or <code>app.config.js</code> file:</p>
  <pre><code class="language-json">{
  "expo": {
    "jsEngine": "hermes"
  }
}</code></pre>

  <h3>Proguard/R8 (Android)</h3>
  <p>Proguard (or R8 in newer Android versions) shrinks, optimizes, and obfuscates your code, removing unused code and renaming classes and methods.  This reduces the final APK size. It's enabled by default in production builds.</p>

  <h3>Minification</h3>
  <p>Minifying your JavaScript code reduces its size by removing whitespace and shortening variable names. Expo's build process automatically minifies your code.</p>

  <h3>Metro Bundler Configuration</h3>
 <p>For advanced control over bundling, you can customize the Metro bundler configuration. This allows for fine-tuning of the bundling process, potentially leading to further performance improvements and size reduction.</p>

  <h3>Environment Variables</h3>
  <p>Use environment variables and <code>.env</code> files to manage different configurations for your builds. This allows you to use different API keys, endpoints, or feature flags depending on the environment (e.g., development, staging, production). The <code>react-native-dotenv</code> package provides a convenient way to access these variables in your React Native code. This also allows you to only include modules in specific builds using variables to import these.</p>
  <h2 id="leveraging-native-modules">Leveraging Native Modules</h2>

  <p>For performance-critical tasks, consider using native modules. These modules are written in native code (Java/Kotlin for Android, Objective-C/Swift for iOS) and can provide significant performance gains compared to JavaScript. However, be judicious in their use, as they add complexity to your project. In some cases, JavaScript may still provide a smaller size.  If applicable, determine if it is truly the best approach for the task.</p>
  <p>If building a native module use <a href="https://docs.expo.dev/modules/what-are-modules/" target="_blank" rel="noopener noreferrer">Expo Modules API</a> to build performant modules for Expo apps.</p>
  <h2 id="testing-and-profiling">Testing and Profiling</h2>
  <p>Testing and profiling are critical steps in the optimization process.</p>

  <p>Use profiling tools like React Native Performance Monitor or Flipper to identify performance bottlenecks. Test your app on real devices with different hardware configurations to get a realistic view of its performance. Consider adding performance monitoring tools such as <a href="https://sentry.io/" target="_blank" rel="noopener noreferrer">Sentry</a> or <a href="https://www.bugsnag.com/" target="_blank" rel="noopener noreferrer">Bugsnag</a></p>

  <h2 id="conclusion">Conclusion</h2>
  <p>Optimizing React Native Expo apps for size and performance is an ongoing process. By implementing the techniques discussed in this post – code optimization, asset management, and strategic bundling – you can significantly improve your app's user experience. Remember that optimization is an ongoing process and requires continuous monitoring and refinement. Implement the techniques discussed and share your experiences in the comments below!</p>
</article>14:T1fa0,<article>
  <h1>How to Optimize and Build React Native Expo Apps: Size and Speed Secrets</h1>

  <p>React Native, combined with Expo, offers a rapid and convenient way to build cross-platform mobile applications. However, a common pitfall is the resulting application's size and performance, especially after building for production. This post provides actionable techniques for optimizing React Native Expo apps during the build process, focusing on reducing size and improving speed. We'll explore code optimization, asset management, bundling strategies, and considerations for native modules.</p>

  <h2 id="understanding-the-build-process">Understanding the Build Process</h2>
  <p>The <code>expo build</code> command is your gateway to creating production-ready binaries (APK for Android and IPA for iOS) from your React Native project. Under the hood, Expo leverages EAS Build (Expo Application Services) to handle bundling and native code compilation. A crucial element in this process is the <code>app.json</code> or <code>app.config.js</code> file, where you define your app's configuration. Proper configuration here is <em>essential</em> for effective optimization.</p>

  <h2 id="code-optimization-techniques">Code Optimization Techniques</h2>
  <p>Optimizing your code is paramount for a lean and performant app.</p>

  <h3>Dead Code Elimination (Tree Shaking)</h3>
  <p>Tree shaking is the process of eliminating unused code from your application bundle. Modern bundlers like Webpack can automatically perform tree shaking. To maximize its effectiveness, avoid global imports. Instead, import only the specific components or functions you need.</p>
  <p>To enable tree shaking, ensure your modules are using ES modules syntax (<code>import</code> and <code>export</code>).</p>

  <h3>Code Splitting (Dynamic Imports)</h3>
  <p>Code splitting involves dividing your application into smaller chunks, loading only the necessary code when needed. Dynamic imports, using <code>React.lazy</code> or the <code>import()</code> syntax, allow you to defer the loading of non-critical modules, reducing initial load time.</p>
  <pre><code class="language-javascript">const MyComponent = React.lazy(() =&gt; import('./MyComponent'));

function MyOtherComponent() {
  return (
    <react.suspense fallback="{<div">Loading...}&gt;
      <mycomponent>
    </mycomponent></react.suspense>
  );
}
</code></pre>

  <h3>Efficient Data Structures and Algorithms</h3>
  <p>Choosing the right data structures (e.g., <code>Map</code> vs. <code>Object</code>) and algorithms based on your specific use cases can significantly impact performance. Profile your application using tools like React Native Performance Monitor or Flipper to identify bottlenecks and optimize accordingly. For example, using <code>Map</code> might be more efficient for frequent lookups than using a plain JavaScript object as a dictionary.</p>

  <h2 id="asset-optimization">Asset Optimization</h2>
  <p>Reducing the size of your assets (images, audio, video) is crucial for a smaller app and faster download times.</p>

  <h3>Image Optimization</h3>
  <p>Compress images using lossy or lossless compression techniques. Lossy compression reduces file size more aggressively but can introduce some visual artifacts. Tools like <a href="https://imageoptim.com/" target="_blank" rel="noopener noreferrer">ImageOptim</a> or <a href="https://tinypng.com/" target="_blank" rel="noopener noreferrer">TinyPNG</a> can help. Consider using WebP images as well, as they offer superior compression compared to JPG and PNG.</p>

  <h3>Asset Resizing and Scaling</h3>
  <p>Provide multiple image resolutions for different screen densities. Expo's asset management system handles this automatically when you use the <code>require()</code> function with image assets.  Ensure you are using appropriate image sizes to avoid unnecessary bandwidth usage.</p>

  <h3>Vector Graphics (SVGs)</h3>
  <p>Use SVG images for icons and simple graphics whenever possible. SVGs are scalable and have a small file size. You can import and use SVGs in your React Native components using libraries like <code>react-native-svg</code>.</p>
  <pre><code class="language-javascript">import Svg, { Rect } from 'react-native-svg';

function MyIcon() {
  return (
    <svg width="24" height="24">
      <rect width="24" height="24" fill="#000"></rect>
    </svg>
  );
}
</code></pre>

  <h3>Audio and Video Optimization</h3>
  <p>If your app includes audio or video assets, optimize them through compression and by using appropriate codecs.</p>

  <h2 id="bundling-strategies">Bundling Strategies</h2>
  <p>The way your code is bundled can significantly affect app size and startup time.</p>

  <h3>Hermes Engine</h3>
  <p>The Hermes JavaScript engine is designed for React Native. It offers improved startup time and reduced app size.  Enable Hermes in your <code>app.json</code> or <code>app.config.js</code> file:</p>
  <pre><code class="language-json">{
  "expo": {
    "jsEngine": "hermes"
  }
}</code></pre>

  <h3>Proguard/R8 (Android)</h3>
  <p>Proguard (or R8 in newer Android versions) shrinks, optimizes, and obfuscates your code, removing unused code and renaming classes and methods.  This reduces the final APK size. It's enabled by default in production builds.</p>

  <h3>Minification</h3>
  <p>Minifying your JavaScript code reduces its size by removing whitespace and shortening variable names. Expo's build process automatically minifies your code.</p>

  <h3>Metro Bundler Configuration</h3>
 <p>For advanced control over bundling, you can customize the Metro bundler configuration. This allows for fine-tuning of the bundling process, potentially leading to further performance improvements and size reduction.</p>

  <h3>Environment Variables</h3>
  <p>Use environment variables and <code>.env</code> files to manage different configurations for your builds. This allows you to use different API keys, endpoints, or feature flags depending on the environment (e.g., development, staging, production). The <code>react-native-dotenv</code> package provides a convenient way to access these variables in your React Native code. This also allows you to only include modules in specific builds using variables to import these.</p>
  <h2 id="leveraging-native-modules">Leveraging Native Modules</h2>

  <p>For performance-critical tasks, consider using native modules. These modules are written in native code (Java/Kotlin for Android, Objective-C/Swift for iOS) and can provide significant performance gains compared to JavaScript. However, be judicious in their use, as they add complexity to your project. In some cases, JavaScript may still provide a smaller size.  If applicable, determine if it is truly the best approach for the task.</p>
  <p>If building a native module use <a href="https://docs.expo.dev/modules/what-are-modules/" target="_blank" rel="noopener noreferrer">Expo Modules API</a> to build performant modules for Expo apps.</p>
  <h2 id="testing-and-profiling">Testing and Profiling</h2>
  <p>Testing and profiling are critical steps in the optimization process.</p>

  <p>Use profiling tools like React Native Performance Monitor or Flipper to identify performance bottlenecks. Test your app on real devices with different hardware configurations to get a realistic view of its performance. Consider adding performance monitoring tools such as <a href="https://sentry.io/" target="_blank" rel="noopener noreferrer">Sentry</a> or <a href="https://www.bugsnag.com/" target="_blank" rel="noopener noreferrer">Bugsnag</a></p>

  <h2 id="conclusion">Conclusion</h2>
  <p>Optimizing React Native Expo apps for size and performance is an ongoing process. By implementing the techniques discussed in this post – code optimization, asset management, and strategic bundling – you can significantly improve your app's user experience. Remember that optimization is an ongoing process and requires continuous monitoring and refinement. Implement the techniques discussed and share your experiences in the comments below!</p>
</article>5:["$","article",null,{"className":"relative min-h-screen bg-white dark:bg-gray-900 text-gray-800 dark:text-gray-100","children":[["$","$Lf",null,{}],["$","div",null,{"className":"max-w-5xl mx-auto px-4 md:px-6 py-8 lg:py-12","children":[["$","header",null,{"className":"mb-10","children":[["$","div",null,{"className":"flex items-center gap-3 mb-4","children":[["$","$L10",null,{"href":"/category/build-optiization","children":["$","span",null,{"className":"inline-flex items-center px-3 py-1 rounded-full bg-[#E8F5E9] text-[#4CAF7D] text-sm font-medium","children":"Build Optiization"}]}],false]}],["$","nav",null,{"className":"text-sm text-gray-600 dark:text-gray-400 mb-4","children":[["$","$L10",null,{"href":"/","className":"hover:underline","children":"Home"}]," ","/"," ",["$","$L10",null,{"href":"/category/build-optiization","className":"hover:underline","children":"Build Optiization"}]," ","/ ",["$","span",null,{"className":"font-semibold","children":"How to Optimize and Build React Native Expo Apps: Size and Speed Secrets"}]]}],["$","h1",null,{"className":"text-3xl sm:text-4xl lg:text-5xl font-bold tracking-tight leading-tight mb-4","children":"How to Optimize and Build React Native Expo Apps: Size and Speed Secrets"}],["$","div",null,{"className":"flex flex-wrap items-center gap-4 text-sm text-gray-600 dark:text-gray-400 mt-6","children":[["$","div",null,{"className":"flex items-center","children":[["$","svg",null,{"ref":"$undefined","xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-clock w-4 h-4 mr-1.5 text-[#4CAF7D]","children":[["$","circle","1mglay",{"cx":"12","cy":"12","r":"10"}],["$","polyline","68esgv",{"points":"12 6 12 12 16 14"}],"$undefined"]}],"Mar 26, 2025"]}],["$","div",null,{"className":"flex items-center","children":[["$","svg",null,{"ref":"$undefined","xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-book-open w-4 h-4 mr-1.5 text-[#4CAF7D]","children":[["$","path","1akyts",{"d":"M12 7v14"}],["$","path","ruj8y",{"d":"M3 18a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1h5a4 4 0 0 1 4 4 4 4 0 0 1 4-4h5a1 1 0 0 1 1 1v13a1 1 0 0 1-1 1h-6a3 3 0 0 0-3 3 3 3 0 0 0-3-3z"}],"$undefined"]}],6," min read"]}]]}]]}],["$","div",null,{"className":"relative w-full aspect-[16/9] rounded-lg overflow-hidden shadow-lg mb-8","children":["$","$L11",null,{"priority":true,"src":"https://images.unsplash.com/photo-1484373030460-8de45ac8796d?q=80&w=2070&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D","alt":"How to Optimize and Build React Native Expo Apps: Size and Speed Secrets","fill":true,"className":"object-cover"}]}],["$","$L12",null,{"content":"$13"}],["$","section",null,{"className":"prose prose-lg dark:prose-invert max-w-none leading-relaxed lg:leading-loose mt-10 mx-auto mb-12","children":["$","div",null,{"dangerouslySetInnerHTML":{"__html":"$14"}}]}],["$","div",null,{"className":"border-t pt-6 mt-12","children":["$","div",null,{"className":"flex flex-col md:flex-row justify-between items-center gap-6","children":["$","div",null,{"children":[["$","h3",null,{"className":"text-sm font-semibold uppercase mb-2","children":"Share this article"}],["$","$L15",null,{"url":"https://yourblog.com/blog/how-to-optimize-and-build-react-native-expo-apps-size-and-speed-secrets","title":"How to Optimize and Build React Native Expo Apps: Size and Speed Secrets"}]]}]}]}]]}]]}]
